<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ad-Hockery</title>
  <id>http://blog.url.com/</id>
  <link href="http://blog.url.com/"/>
  <link href="http://blog.url.com/feed.xml" rel="self"/>
  <updated>2014-08-11T11:46:00+01:00</updated>
  <author>
    <name>Rob Fletcher</name>
  </author>
  <entry>
    <title>Multiple interface mocks with Spock</title>
    <link rel="alternate" href="http://blog.url.com/2014/08/11/multiple-interface-mocks-with-spock/"/>
    <id>http://blog.url.com/2014/08/11/multiple-interface-mocks-with-spock/</id>
    <published>2014-08-11T11:46:00+01:00</published>
    <updated>2014-08-11T14:41:06+01:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;div class="paragraph"&gt;
&lt;p&gt;Spock&amp;#8217;s &lt;code&gt;Mock&lt;/code&gt; factory method (as well as factories for the other types of test double; &lt;code&gt;Stub&lt;/code&gt; &amp;amp; &lt;code&gt;Spy&lt;/code&gt;) accepts a single interface representing the type you need a test double for. But what should you do if you need a test double that implements multiple interfaces?&lt;/p&gt;
&lt;/div&gt;

&lt;div class="paragraph"&gt;
&lt;p&gt;In some situations where code accepts flexible parameter types and is using runtime dispatching (or &lt;code&gt;instanceof&lt;/code&gt; checks) internally to perform different behavior we&amp;#8217;d want to test that different types were handled correctly.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;A trivial example might be a method like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;class A {
  private Writer writer

  void handle(Writable thing) {
    try {
      thing.write(writer)
    } finally {
      if (thing instanceof Closeable) {
        thing.close()
      }
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;we&amp;#8217;d want to test that not only is the &lt;code&gt;write&lt;/code&gt; method from &lt;code&gt;Writable&lt;/code&gt; called but that if the parameter we pass is &lt;code&gt;Closeable&lt;/code&gt; it gets closed properly as well.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The simplest case, where the parameter &lt;em&gt;isn&amp;#8217;t&lt;/em&gt; &lt;code&gt;Closeable&lt;/code&gt; is easy to test:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;@Subject a = new A()

def "writes a writable"() {
  given:
  def x = Mock(Writable)

  when:
  a.handle(x)

  then:
  1 * x.write(_)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;But when we need the mock parameter to implement the &lt;code&gt;Closeable&lt;/code&gt; interface as well as &lt;code&gt;Writable&lt;/code&gt; in order to drive the variant behavior it&amp;#8217;s not so obvious what to do. The following tests will fail because the &lt;code&gt;isntanceof&lt;/code&gt; check in the &lt;code&gt;handle&lt;/code&gt; method will return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;def "writes and closes a closeable writable"() {
  given:
  def x = Writable(Writable)

  when:
  a.handle(x)

  then:
  1 * x.write(_)
  1 * x.close()
}

def "closes a closeable even if writing fails"() {
  given:
  def x = Mock(Writable) {
    write(_) &amp;gt;&amp;gt; { throw new IOException() }
  }

  when:
  a.handle(x)

  then:
  1 * x.close()
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Although it might be nice you cannot do something like:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;def mock = Mock(Comparable, Closeable)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;We could cast around for some class that happens to implement both interfaces and then use a &lt;code&gt;Spy&lt;/code&gt; but the simplest and cleanest solution is to just create our own interface inside the specification class:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;private static interface CloseableWritable extends Writable, Closeable {}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Then in the feature methods we can just use:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;given:
def x = Mock(CloseableWritable)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;In retrospect this solution is the most obvious thing in the world but it took me a little while to remember that an interface can extend more than one other interface. Since we never actually need to implement &lt;code&gt;CloseableWritable&lt;/code&gt; with anything other than a mock it makes sense to encapsulate it inside the specification class.&lt;/p&gt;
&lt;/div&gt;</content>
  </entry>
  <entry>
    <title>Spock and Hamcrest</title>
    <link rel="alternate" href="http://blog.url.com/2014/08/07/spock-and-hamcrest/"/>
    <id>http://blog.url.com/2014/08/07/spock-and-hamcrest/</id>
    <published>2014-08-07T11:23:00+01:00</published>
    <updated>2014-08-11T14:40:56+01:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;div class="paragraph"&gt;
&lt;p&gt;Groovy&amp;#8217;s &lt;em&gt;power assert&lt;/em&gt; and Hamcrest matchers both solve a similar problem – getting decent diagnostic information from an assertion failure. When writing JUnit or Spock tests in Groovy it&amp;#8217;s typical to not use Hamcrest matchers as the &lt;em&gt;power assert&lt;/em&gt; is so much simpler and just as effective. It&amp;#8217;s worth bearing in mind, though that Hamcrest is also for helping clearly express the intent of an assertion. Spock provides support for Hamcrest matchers and I recently ran into a situation where I think it was the right thing to use.&lt;/p&gt;
&lt;/div&gt;

&lt;div class="paragraph"&gt;
&lt;p&gt;If we&amp;#8217;re testing a method that returns a &lt;code&gt;Collection&lt;/code&gt; that may contain duplicate entries but whose order is either non-deterministic or irrelevant to the test what is the best way to make an assertion about the content of the collection?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Imagine we&amp;#8217;re testing this interface:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;interface Api {
  List&amp;lt;String&amp;gt; getThings()
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The return value here is &lt;code&gt;List&lt;/code&gt; but it could be a &lt;em&gt;bag&lt;/em&gt; or some other collection type. It &lt;strong&gt;cannot&lt;/strong&gt; be &lt;code&gt;Set&lt;/code&gt; as the method may return a collection containing elements with a cardinality greater than 1.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Naïvely we might test it like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;expect:
api.things == expected

where:
expected = ["a", "a", "b"]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;If the order of the elements is non-deterministic this will sometimes pass and sometimes fail. No good.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Next we might try converting the result and the expectation to a &lt;code&gt;Set&lt;/code&gt; so that the comparison does not take order into account:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;expect:
api.things as Set == expected as Set&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This will pass, but it can mask an error in the implementation because it&amp;#8217;s not testing the cardinality of the elements. If &lt;code&gt;getThings()&lt;/code&gt; returns &lt;code&gt;["a", "b"]&lt;/code&gt; or &lt;code&gt;["a", "a", "a", "a", "b"]&lt;/code&gt; the test will still pass which is almost certainly not what we intend.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Another route is to enforce an artificial ordering for the purposes of testing:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;expect:
api.things.sort() == expected&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This works so long as the element type is &lt;code&gt;Comparable&lt;/code&gt; but I don&amp;#8217;t find it very clear. As a reader of this code it might not be obvious why the sort is being done. The assertion is correct but at the cost of some clarity.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;I &lt;a href="https://twitter.com/rfletcherEW/status/490051366807961600"&gt;tweeted about this&lt;/a&gt; and got the following suggestion:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;expect:
def actual = api.things
actual.containsAll(expected) &amp;amp;&amp;amp; actual.size() == expected.size()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This appears thorough but also masks an error. The assertion will pass if the the actual result is &lt;code&gt;["a", "a", "b"]&lt;/code&gt; or &lt;code&gt;["a", "b", "b"]&lt;/code&gt;. It&amp;#8217;s checking the size of the list but not the cardinality of individual elements.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;a href="https://twitter.com/RobElliot266/status/490058541500469248"&gt;Rob Elliot pointed out&lt;/a&gt; that there&amp;#8217;s a Hamcrest matcher for exactly this condition. Using that, I think yields the best result for clarity and correctness:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;expect:
that api.things, containsInAnyOrder(*expected)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;One of the huge advantages of Spock and Groovy&amp;#8217;s power assert are in the expressiveness of test code but I think using Hamcrest in this case provides a more readable solution.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_implementation"&gt;Implementation&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;To get this to work you need to import the &lt;em&gt;hamcrest-all&lt;/em&gt; library that contains a lot more matchers than the &lt;em&gt;hamcrest-core&lt;/em&gt; library that Spock pulls in by default.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="title"&gt;build.gradle&lt;/div&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;testCompile "org.hamcrest:hamcrest-all:1.3"&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Then you can static import Spock&amp;#8217;s &lt;code&gt;that&lt;/code&gt; method and the matcher itself:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;import static spock.util.matcher.HamcrestSupport.that
import static org.hamcrest.Matchers.containsInAnyOrder&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content>
  </entry>
  <entry>
    <title>Closures and field visibility</title>
    <link rel="alternate" href="http://blog.url.com/2014/07/21/closures-and-field-visibility/"/>
    <id>http://blog.url.com/2014/07/21/closures-and-field-visibility/</id>
    <published>2014-07-21T11:34:00+01:00</published>
    <updated>2014-07-21T14:34:25+01:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;div class="paragraph"&gt;
&lt;p&gt;I find Groovy Closures can sometimes behave in ways that, once I think about it, make perfect sense but initially seem surprising. One example of this is the fact that closures &lt;em&gt;declared in a parent class&lt;/em&gt; cannot “see” private fields of that class when run in the context of a child class.&lt;/p&gt;
&lt;/div&gt;

&lt;div class="paragraph"&gt;
&lt;p&gt;Take a look at this code:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;class Multiplier {

  private int multiplier

  Multiplier(int multiplier) {
    this.multiplier = multiplier
  }

  List multiply(List values) {
    values.collect {
      it * multiplier
    }
  }
}

assert new Multiplier(3).multiply([1, 2, 3]) == [3, 6, 9]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The class has a private field &lt;code&gt;multiplier&lt;/code&gt; that gets referenced in a closure in one of the class methods. This works fine. However, what happens if we extend that class?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;class Doubler extends Multiplier {
  Doubler() { super(2) }
}

assert new Doubler().multiply([1, 2, 3]) == [2, 4, 6]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This code results in &lt;code&gt;MissingPropertyException: No such property: multiplier for class: Doubler&lt;/code&gt;!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;A closure gets compiled as an anonymous inner class and when run will attempt to resolve unknown property references against its &lt;em&gt;owner&lt;/em&gt; – in this case the object that contains it. Because the &lt;code&gt;multiplier&lt;/code&gt; field is not visible from the &lt;code&gt;Doubler&lt;/code&gt; class the reference doesn&amp;#8217;t work. If &lt;code&gt;multiplier&lt;/code&gt; is declared &lt;code&gt;protected&lt;/code&gt; the code works just fine.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This is definitely worth bearing in mind if you are building library code designed to be extended by other people.&lt;/p&gt;
&lt;/div&gt;</content>
  </entry>
  <entry>
    <title>@CompileStatic and polymorphic method dispatch</title>
    <link rel="alternate" href="http://blog.url.com/2014/07/08/compilestatic-and-polymorphic-method-dispatch/"/>
    <id>http://blog.url.com/2014/07/08/compilestatic-and-polymorphic-method-dispatch/</id>
    <published>2014-07-08T07:11:00+01:00</published>
    <updated>2014-07-18T06:14:28+01:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;div class="paragraph"&gt;
&lt;p&gt;I&amp;#8217;m a big fan of Groovy&amp;#8217;s &lt;code&gt;@CompileStatic&lt;/code&gt; feature – so much so that I&amp;#8217;ve updated the &lt;em&gt;Groovy class&lt;/em&gt; template in IntelliJ IDEA to use it by default. I should stress I don&amp;#8217;t do this because I believe non-statically compiled Groovy to be slow – it isn&amp;#8217;t.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Recently &lt;a href="https://twitter.com/pledbrook/status/475986668840050688"&gt;Peter Ledbrook reminded me of one drawback&lt;/a&gt; which is that method dispatch is statically bound when using &lt;code&gt;@CompileStatic&lt;/code&gt; like it is in Java. This means that the behavior of calling polymorphic methods can change when argument types are not known at compile time.&lt;/p&gt;
&lt;/div&gt;

&lt;div class="paragraph"&gt;
&lt;p&gt;Here&amp;#8217;s a simple example. What will this code print?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;class Categorizer {

  void accept(String s) { println "String: '$s'" }
  void accept(Number n) { println "Number: $n" }
  void accept(Object o) { println "Object: $o" }

  void accept(Object... objects) {
    objects.each {
      accept(it)
    }
  }
}

new Categorizer().accept(
  "a",
  "${'b'}",
  1,
  true,
  ["c", "d", 2] as Object[]
)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This is straight up dynamic Groovy so we get this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre&gt;String: 'a'
String: 'b'
Number: 1
Object: true
String: 'c'
String: 'd'
Number: 2&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Dynamically compiled Groovy uses runtime method dispatch meaning that the version of &lt;code&gt;Categorizer.accept&lt;/code&gt; to use for the statement &lt;code&gt;accept(it)&lt;/code&gt; is determined at runtime based on the type of &lt;code&gt;it&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;What happens to that output if we add &lt;code&gt;@CompileStatic&lt;/code&gt; to the &lt;code&gt;Categorizer&lt;/code&gt; class? The output changes to this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre&gt;Object: a
Object: b
Object: 1
Object: true
Object: [c, d, 2]&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Now the statement &lt;code&gt;accept(it)&lt;/code&gt; is bound at &lt;em&gt;compile time&lt;/em&gt; and there is no type information about &lt;code&gt;it&lt;/code&gt;. The compiler&amp;#8217;s only choice is to bind to &lt;code&gt;accept(Object)&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This is completely logical when you understand what the compiler is doing but it&amp;#8217;s behavior that annoyed me back when I was using Java full time and I much prefer Groovy&amp;#8217;s runtime dispatch.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;There is a compromise, though. Instead of full static compilation you can enable static type checking in the Groovy compiler using &lt;code&gt;@TypeChecked&lt;/code&gt;. With &lt;code&gt;@TypeChecked&lt;/code&gt; the call to &lt;code&gt;accept(it)&lt;/code&gt; is dispatched at runtime and the output is the same as the original.&lt;/p&gt;
&lt;/div&gt;</content>
  </entry>
  <entry>
    <title>Enabling Groovy’s “invokedynamic” support in Gradle</title>
    <link rel="alternate" href="http://blog.url.com/2014/06/24/enabling-groovys-invokedynamic-support-in-gradle/"/>
    <id>http://blog.url.com/2014/06/24/enabling-groovys-invokedynamic-support-in-gradle/</id>
    <published>2014-06-24T15:46:00+01:00</published>
    <updated>2014-07-13T08:33:13+01:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;div class="paragraph"&gt;
&lt;p&gt;I posted &lt;a href="/post/89759686171/gradle-and-groovys-invoke-dynamic-support"&gt;previously&lt;/a&gt; about configuring a Gradle project to ensure that only the &lt;em&gt;indy&lt;/em&gt; version of Groovy (that is the variant that supports Java 7&amp;#8217;s &lt;em&gt;invokedynamic&lt;/em&gt; bytecode instruction) is included in the dependency graph. However, just including that version of the Groovy jar is &lt;strong&gt;not&lt;/strong&gt; enough to make your Groovy code compile in such a way that it uses &lt;em&gt;invokedynamic&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;

&lt;div class="paragraph"&gt;
&lt;p&gt;In addition to including the right version of the jar you need to configure Gradle&amp;#8217;s &lt;code&gt;GroovyCompile&lt;/code&gt; task like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="title"&gt;build.gradle&lt;/div&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;tasks.withType(GroovyCompile) {
  groovyOptions.optimizationOptions.indy = true
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;If you want to check the code is being compiled correctly the easiest way I&amp;#8217;ve found to do so is to use &lt;code&gt;javap&lt;/code&gt; to read the bytecode form a class file and see if there are any &lt;em&gt;invokedynamic&lt;/em&gt; instructions. Here&amp;#8217;s an example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="bash language-bash"&gt;javap -v -cp build/classes/test co.freeside.jdbi.time.LocalDateSpec | grep invokedynamic&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;If the class is compiled with the &lt;em&gt;indy&lt;/em&gt; option set you&amp;#8217;ll see some output. Here&amp;#8217;s what I get from that class:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre&gt; 3: invokedynamic #46,  0             // InvokeDynamic #0:init:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Object;
 8: invokedynamic #52,  0             // InvokeDynamic #1:cast:(Ljava/lang/Object;)Lorg/skife/jdbi/v2/tweak/ResultSetMapper;
 2: invokedynamic #62,  0             // InvokeDynamic #2:getProperty:(Ljava/lang/Class;)Ljava/lang/Object;
 7: invokedynamic #52,  0             // InvokeDynamic #1:cast:(Ljava/lang/Object;)Lorg/skife/jdbi/v2/tweak/ResultSetMapper;
 3: invokedynamic #70,  0             // InvokeDynamic #3:getProperty:(Lco/freeside/jdbi/time/LocalDateSpec;)Ljava/lang/Object;
 8: invokedynamic #76,  0             // InvokeDynamic #4:invoke:(Ljava/lang/Class;Ljava/lang/Object;)Ljava/lang/Object;
13: invokedynamic #79,  0             // InvokeDynamic #1:cast:(Ljava/lang/Object;)Ljava/time/LocalDate;
32: invokedynamic #95,  0             // InvokeDynamic #1:cast:(Lgroovy/lang/GString;)Ljava/lang/String;
35: invokedynamic #95,  0             // InvokeDynamic #1:cast:(Lgroovy/lang/GString;)Ljava/lang/String;
32: invokedynamic #95,  0             // InvokeDynamic #1:cast:(Lgroovy/lang/GString;)Ljava/lang/String;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Of course, bear in mind that not all classes will contain any &lt;em&gt;invokedynamic&lt;/em&gt; instructions. If you&amp;#8217;ve used &lt;code&gt;@CompileStatic&lt;/code&gt; for example method calls are not dispatched dynamically.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; &lt;a href="https://twitter.com/CedricChampeau/status/481451226790645760"&gt;Cédric Champeau pointed out&lt;/a&gt; that you should use JDK 7u60 or above to avoid any potential &lt;em&gt;invokedynamic&lt;/em&gt; related bugs.&lt;/p&gt;
&lt;/div&gt;</content>
  </entry>
  <entry>
    <title>Gradle and Groovy’s Invoke Dynamic support</title>
    <link rel="alternate" href="http://blog.url.com/2014/06/24/gradle-and-groovys-invoke-dynamic-support/"/>
    <id>http://blog.url.com/2014/06/24/gradle-and-groovys-invoke-dynamic-support/</id>
    <published>2014-06-24T15:32:00+01:00</published>
    <updated>2014-07-13T08:33:47+01:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;div class="paragraph"&gt;
&lt;p&gt;Since version 2.0 the Groovy distribution has included an alternate artifact that enables &lt;a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html#invokedynamic"&gt;invoke dynamic&lt;/a&gt; support.&lt;/p&gt;
&lt;/div&gt;

&lt;div class="paragraph"&gt;
&lt;p&gt;You can include that in a Gradle project by specifying a dependency like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="title"&gt;build.gradle&lt;/div&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;compile "org.codehaus.groovy:groovy-all:2.3.3:indy"&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;However if you have other libraries that depend on groovy they may pull in the regular version transitively giving you two versions of Groovy in your dependency graph. This happens to me a lot with Spock which depends on &lt;em&gt;groovy-all:2.0.5&lt;/em&gt;. For example I probably have a dependency like this as well:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="title"&gt;build.gradle&lt;/div&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;testCompile "org.spockframework:spock-core:0.7-groovy-2.0"&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;I noticed that the &lt;em&gt;External Libraries&lt;/em&gt; section of the project tree in &lt;em&gt;IntelliJ IDEA&lt;/em&gt; contained two &lt;em&gt;groovy-all&lt;/em&gt; jars. One is &lt;em&gt;groovy-all-2.3.3&lt;/em&gt; and the other is &lt;em&gt;groovy-all-2.3.3-indy&lt;/em&gt;. That&amp;#8217;s not good. I only want the &lt;em&gt;indy&lt;/em&gt; version.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;To debug where the dependency is coming from you can use Gradle&amp;#8217;s &lt;code&gt;dependencyInsight&lt;/code&gt; target like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="bash language-bash"&gt;gradle dependencyInsight --dependency groovy-all&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;By default the &lt;code&gt;dependencyInsight&lt;/code&gt; only searches the &lt;em&gt;compile&lt;/em&gt; configuration and you may well see nothing there. You can search other configurations by adding an argument on the command line. For example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="bash language-bash"&gt;gradle dependencyInsight --dependency groovy-all --configuration testCompile&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The output from the command looks like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre&gt;:dependencyInsight
org.codehaus.groovy:groovy-all:2.3.3 (conflict resolution)
\--- compile

org.codehaus.groovy:groovy-all:2.0.5 -&amp;gt; 2.3.3
\--- org.spockframework:spock-core:0.7-groovy-2.0
     \--- testCompile&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here we can see &lt;em&gt;groovy-all&lt;/em&gt; version &lt;em&gt;2.3.3&lt;/em&gt; explicitly included as a &lt;em&gt;compile&lt;/em&gt; dependency &lt;strong&gt;and&lt;/strong&gt; pulled in transitively by Spock. Gradle&amp;#8217;s conflict resolution has selected version &lt;em&gt;2.3.3&lt;/em&gt; but what the output doesn&amp;#8217;t show us is the variant. It doesn&amp;#8217;t appear to be possible to tell whether the &lt;em&gt;indy&lt;/em&gt; or regular flavor of &lt;em&gt;groovy-all&lt;/em&gt; is pulled in.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;To fix this I first tried forcing the version with:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="title"&gt;build.gradle&lt;/div&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;configurations.all {
  resolutionStrategy {
    force "org.codehaus.groovy:groovy-all:2.3.3:indy"
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The &lt;code&gt;dependencyInsight&lt;/code&gt; output changed a little:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre&gt;:dependencyInsight
org.codehaus.groovy:groovy-all:2.3.3 (forced)
\--- compile

org.codehaus.groovy:groovy-all:2.0.5 -&amp;gt; 2.3.3
\--- org.spockframework:spock-core:0.7-groovy-2.0
     \--- testCompile&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;However, I could still see both versions of &lt;em&gt;groovy-all&lt;/em&gt; in IDEA&amp;#8217;s project tree. It looks like the &lt;em&gt;force&lt;/em&gt; resolution strategy doesn&amp;#8217;t take into account the variant you request.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Unfortunately the only way to get evict the regular &lt;em&gt;groovy-all&lt;/em&gt; jar from the dependency tree seems to be to explicitly exclude it from every dependency that pulls it in transitively. For example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="title"&gt;build.gradle&lt;/div&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;testCompile("org.spockframework:spock-core:0.7-groovy-2.0") {
  exclude module: "groovy-all"
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Finally the extra jar is gone from IDEA.&lt;/p&gt;
&lt;/div&gt;</content>
  </entry>
</feed>
