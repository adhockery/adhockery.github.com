<!doctype html>
<html class="no-js">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Ad-Hockery - Organizing functional tests</title>
    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" />
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/Icon.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/Icon@2x.png">
    <link rel="stylesheet" href="/stylesheets/adhockery.css">
    <link rel="stylesheet" href="/stylesheets/prism.css">
    <script src="/javascripts/modernizr.custom.js"></script>
    <script src="//use.edgefonts.net/ultra;league-gothic.js"></script>
  </head>
  <body>

    <header>
      <h1 class="logo"><a href="/">Ad-Hockery</a></h1>
      <dl class="strapline">
        <dt>ad-hockery: <em>/ad·hok'@r·ee/</em>, n.</dt>
        <dd>Gratuitous assumptions... which lead to the appearance of semi-intelligent behavior but are in fact entirely arbitrary. <cite><a href="http://www.retrologic.com/jargon/A/ad-hockery.html">Jargon File</a></cite>
      </dl>
    </header>

    <div class="container">
      <main>
          <article>
    <header>
      <time datetime="2011-11-30T23:27:00">Nov 30 2011</time>
      <h1>Organizing functional tests</h1>
    </header>
    <div class="paragraph">
<p>I posted a few days ago <a href="http://blog.freeside.co/post/42903299940/fear-loathing-in-functional-testing-land">about functional testing &amp; some of my frustrations</a>, focusing mainly on the technical issues. I did touch on test organization in terms of modelling behaviour rather than page structure. As <a href="http://ldaley.com/post/13251886270/in-response-to-robs-post-on-functional-testing">Luke Daley has pointed out</a> the two aren&#8217;t fundamentally in opposition and I&#8217;ve been giving this some further thought.</p>
</div>

<div class="paragraph">
<p>I think the crux of the issue is that functional tests, end-to-end tests, acceptance tests, whatever you want to call them are <em>not</em> the same thing as unit tests. They&#8217;re not really even just a higher level of the same thing. Yet on the projects I&#8217;ve worked on we&#8217;ve generally carried on as though they were.</p>
</div>
<div class="paragraph">
<p>Unit tests are associated almost on a one-to-one basis with units of code. When you execute <code>grails create-controller Foo</code> the framework generates a skeleton controller and a unit test for it. You certainly shouldn&#8217;t be slavishly beholden to the one unit test class per production class habit but it&#8217;s generally reasonable. Each unit test describes the behaviour of a single unit of the software. I don&#8217;t think the same association <em>is</em> appropriate for functional tests but we often end up using it anyway.</p>
</div>
<div class="paragraph">
<p>I&#8217;ve tried to distil some rules of thumb from all this.</p>
</div>
<div class="sect2">
<h3 id="_1_organize_tests_around_features_not_units_of_code">1: Organize tests around features not units of code</h3>
<div class="paragraph">
<p>When it comes to writing functional tests in Java or Groovy the tendency is to follow the pattern of associating tests to some kind of unit of software. Typically it&#8217;s a test per web page or significant page component (e.g. <em>ArticlePageSpec</em>, <em>NewsTickerSpec</em>). When dealing with the content management side of apps rather than the public facing it often defaults to a test per high level domain object.</p>
</div>
<div class="paragraph">
<p>When work is started on new functionality the temptation is often to augment existing tests rather than creating new ones. Oh, this card deals with <em>article</em> pages on the site so let&#8217;s go find the <em>ArticlePageSpec</em> and add our coverage there.</p>
</div>
<div class="paragraph">
<p>The functional tests are supposed to be, among other things, the living, executable documentation for your product. So there should be a strong association between the tests and the features that have been implemented over the life of the project. In the teams I&#8217;ve worked on features have been tracked using index cards on a board but the same could apply to issue tracking systems. When using <em>Spock</em> there&#8217;s even a dedicated annotation for tying a feature method or specification class to an issue:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="groovy language-groovy">import spock.lang.*

@Issue("https://github.com/robfletcher/betamax/issues/34")
class HttpsProxySpec extends Specification {</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_2_em_name_em_tests_according_to_features">2: <em>Name</em> tests according to features</h3>
<div class="paragraph">
<p>I think part of the reason the habit of associating tests with units of code is hard to break is naming. Test classes have to be called something and that something is limited by Java&#8217;s class naming requirements and conventions. Naming things is often treated as an afterthought, <a href="http://martinfowler.com/bliki/TwoHardThings.html">but it&#8217;s actually hard</a>. When I start working on a card with a description something like <em>"A user can save articles to a list of <em>favourites</em>"</em> what am I going to call the functional test class? I should probably go for <em>UserSavesArticleToFavouritesSpec</em> but if this is the first card played that&#8217;s to do with <em>favourites</em> maybe I&#8217;ll just be lazy and call it <em>FavouritesSpec</em>. Next week someone else plays a card <em>"Users can remove articles from their list of favourites"</em> and adds their coverage to my original <em>FavouritesSpec</em> which is now some hybrid beast testing two different bits of behaviour.</p>
</div>
</div>
<div class="sect2">
<h3 id="_3_put_tests_somewhere_you_can_find_them_later">3: Put tests somewhere you can find them later</h3>
<div class="paragraph">
<p>Over time something I&#8217;ve noticed is that it becomes difficult to identify where exactly a certain bit of functionality is covered in the functional tests. Team members fixing defects will sometimes try to figure out who implemented something in the first place and ask them where the tests are or even end up trawling through the <em>Git</em> log. This shouldn&#8217;t be necessary.</p>
</div>
<div class="paragraph">
<p>A corollary to that is that it also becomes difficult to identify redundancy or obsolescence in the functional tests. If a feature of the application is removed or replaced then obviously the tests around it should also be removed. The <em>wrong</em> way to do that is by running everything and deleting whatever fails.</p>
</div>
<div class="paragraph">
<p>I&#8217;ve also seen test cruft floating around (still <em>passing</em> somehow) from long-dead features. In some cases so long-dead that we&#8217;ve had to go rooting through the code because we can&#8217;t remember whether the functionality still exists.</p>
</div>
<div class="paragraph">
<p>Redundancy is a huge problem on some projects. One in particular had a vast suite of <em>Selenese</em> tests that often repeatedly exercised bits of functionality often nothing to do with what the test was concerned with actually testing. For example the CMS used the <em>Grails</em> URL convention of <em>/type/action/id</em> (e.g. <em>/article/edit/1234</em>). Because such URLs are unpredictable tests would do things like invoke a data fixture then use the CMS&#8217;s search tool to find the thing the fixture created and navigate to its edit page.</p>
</div>
</div>
<div class="sect2">
<h3 id="_4_keep_tests_atomic">4: Keep tests atomic</h3>
<div class="paragraph">
<p>There&#8217;s a best practice that states each test should make a single logical assertion and I&#8217;d extend that to say that test classes should test a single feature (including variations and edge cases). If the new test you&#8217;re writing is nothing to do with the other tests in the class or is only related to them because it deals with some of the same parts of the application then it should be broken out into a new class.</p>
</div>
<div class="paragraph">
<p>Sometimes this comes at the cost of repeated initialization or data setup and developers' natural DRY instincts resist that. But in the long run well organized tests will pay dividends over pristine DRY-ness especially as the requirements of individual tests have a habit of mutating over time so that what is common now may not stay that way.</p>
</div>
<div class="paragraph">
<p><em>Selenese</em> tests seem particularly prone to run-on testing where what are in reality multiple tests are combined into one because it is easy for the resulting state of an earlier part of the test to feed into further assertions. For example a test that creates an <em>article</em> then makes sure the user can search for it, then uses the search result to navigate to an edit page where it makes sure the <em>article</em> can be updated and finally deleted. A <a href="http://blog.james-carr.org/2006/11/03/tdd-anti-patterns/">TDD anti-pattern</a> known as <em>"The One"</em>. Spock&#8217;s <em>@Stepwise</em> annotation can be similarly abused.</p>
</div>
</div>
<div class="sect2">
<h3 id="_5_isolate_data_fixtures_for_each_test">5: Isolate data fixtures for each test</h3>
<div class="paragraph">
<p>Starting out with simple tests that create some data we&#8217;ll often spot some commonality &amp; move some of the data setup into <em>setup</em> or <em>setupSpec</em> methods (<em>@Before</em> or <em>@BeforeClass</em> in JUnit). When successive cards are played and developers augment that test they&#8217;ll find the original data is insufficient or inappropriate. Before long there&#8217;s a test with some data created in <em>setup</em>, individual tests adding more, some tests ignoring the data from <em>setup</em> completely and worse, some tests actually modifying or even deleting bits of it.</p>
</div>
<div class="paragraph">
<p>This is not a recipe for a maintainable test. The problems compound themselves. It may not be obvious that one of the tests methods doesn&#8217;t actually need the data provided by the <em>setup</em> method so it gets left there as the test evolves. Eventually it can reach a point where the test has changed so much that virtually <em>none</em> of the individual tests actually need the data provided by the <em>setup</em> method or all of them make significant changes to it but it&#8217;s still sitting there anyway because that fact isn&#8217;t apparent without a very close reading of the code.</p>
</div>
<div class="paragraph">
<p>I&#8217;m not saying don&#8217;t write tests that share data created in <em>setup</em>. But do it sparingly and don&#8217;t then add tests that don&#8217;t need that data; put them somewhere else.</p>
</div>
<div class="paragraph">
<p>I do prefer tests that set up their own data rather than relying on a common fixture. I think it makes the test read better: the fixture becomes part of the test&#8217;s preconditions (the <em>given</em> in the BDD <em>given, when, then</em> structure). That&#8217;s not to say that tests can&#8217;t share fixtures. Factory methods, fixture loaders and so on are appropriate ways of doing that.</p>
</div>
<div class="paragraph">
<p>Grails has a couple of plugins that are very useful here; <em>Fixtures</em> and <em>Build Test Data</em>. I&#8217;m actually pretty bad at using the <em>Fixtures</em> plugin effectively but am convinced it&#8217;s a good idea. <em>Build Test Data</em> is usually among the first plugins I install in any project and it&#8217;s very useful for hiding irrelevant fixture detail from the test code.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tl_dr_version">TL;DR version</h3>
<div class="paragraph">
<p>I firmly believe that small is good when it comes to functional tests. I want lots of tests each covering some well defined facet of the application&#8217;s behaviour, preferably traceable in some way to the original card. I think if I&#8217;ve understood anything of Behaviour Driven Development it&#8217;s that tests should be organized around product features and not units of code.</p>
</div>
</div>
<div class="sect2">
<h3 id="__em_still_em_tl_dr_version"><em>Still</em> TL;DR version</h3>
<div class="paragraph">
<p>I should probably start using <a href="http://cukes.info/">Cucumber</a>.</p>
</div>
</div>
    <footer>
      <ul class="tag-list">
          <li><a href="/tags/testing/">testing</a></li>
      </ul>
    </footer>
  </article>

      </main>

      <footer>
        <nav>
          <a href="/">Home</a>
          <a href="/about">About</a>
          <a href="/archive">Archive</a>
        </nav>
      </footer>
    </div>

    <script src="/javascripts/adhockery.js"></script>
    <script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-27275689-1', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>

<footer class="disqus">
  <div id="disqus_thread"></div>
            <script type="text/javascript">
            //<![CDATA[
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//adhockery.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            //]]>
            </script>
            <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        </script>
</footer>
