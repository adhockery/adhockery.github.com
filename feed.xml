<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ad-Hockery</title>
  <id>http://blog.freeside.co/</id>
  <link href="http://blog.freeside.co/"/>
  <link href="http://blog.freeside.co/feed.xml" rel="self"/>
  <updated>2015-06-27T10:16:00-07:00</updated>
  <author>
    <name>Rob Fletcher</name>
  </author>
  <entry>
    <title>Kotlin</title>
    <link rel="alternate" href="http://blog.freeside.co/2015/06/27/kotlin/"/>
    <id>http://blog.freeside.co/2015/06/27/kotlin/</id>
    <published>2015-06-27T10:16:00-07:00</published>
    <updated>2015-06-27T11:54:03-07:00</updated>
    <author>
      <name>Rob Fletcher</name>
    </author>
    <content type="html">&lt;div class="paragraph"&gt;
&lt;p&gt;Peter Ledbrook wrote an interesting post &lt;a href="http://blog.cacoethes.co.uk/software/exploring-kotlin"&gt;Exploring Kotlin&lt;/a&gt; about his initial experiences with Kotlin.
Since I&amp;#8217;ve been getting quite into Kotlin recently I thought I&amp;#8217;d follow that up with some of my own observations as well as responding to some of the questions he raised.&lt;/p&gt;
&lt;/div&gt;

&lt;div class="paragraph"&gt;
&lt;p&gt;The most compelling feature of Kotlin for me is the way it handles &lt;code&gt;null&lt;/code&gt; and nullable types.
You may be familiar with the debate around the use of &lt;code&gt;Optional&amp;lt;?&amp;gt;&lt;/code&gt; in Java 8.
Some people argue that it&amp;#8217;s too little too late to add option types to the language now.
We have however many thousand libraries liberally returning and accepting &lt;code&gt;null&lt;/code&gt; so we still need to do &lt;code&gt;null&lt;/code&gt; checking anyway.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Option types are familiar to most of us from Scala and Guava.
One of the things that most disappointed me about Scala is that it doesn&amp;#8217;t enforce null-safety at compile time.
Instead it&amp;#8217;s just frowned upon to use &lt;code&gt;null&lt;/code&gt; which is fine until you want to use one of those Java libraries I mentioned earlier.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Kotlin is designed for interoperability with Java.
It&amp;#8217;s a pragmatic language that expects you to want to use all those Java APIs you&amp;#8217;ve spent years getting familiar with.
To that end it has an incredibly smart solution to the &lt;code&gt;null&lt;/code&gt; versus option type debate.
Simply, nullable references in Kotlin &lt;em&gt;behave like option types&lt;/em&gt;.
Kotlin&amp;#8217;s &lt;code&gt;String?&lt;/code&gt; is very very like &lt;code&gt;Optional&amp;lt;String&amp;gt;&lt;/code&gt; in Java 8 or &lt;code&gt;Option[String]&lt;/code&gt; in Scala.
Kotlin just provides first-class syntactic support for using its nullable / option types.
For example &lt;code&gt;maybeString?.toString()&lt;/code&gt; in Kotlin is equivalent to &lt;code&gt;maybeString.map(String::toString)&lt;/code&gt; in  Java 8 or &lt;code&gt;maybeString.map(_.toString())&lt;/code&gt; in Scala.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Because Java doesn&amp;#8217;t have such type safety return types from methods on Java classes are considered nullable (most of the time – more on this later).
So a Java method &lt;code&gt;public String toUpperCase(String s)&lt;/code&gt; is seen by Kotlin code as &lt;code&gt;fun toUpperCase(s: String?): String?&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The Kotlin compiler enforces null safety.
That means you can&amp;#8217;t, for example, call &lt;code&gt;it.method()&lt;/code&gt; if &lt;code&gt;it&lt;/code&gt; might be &lt;code&gt;null&lt;/code&gt;.
First you must ensure it isn&amp;#8217;t &lt;code&gt;null&lt;/code&gt; by either using an explicit check:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="kotlin language-kotlin"&gt;if (it != null) {
  it.method()
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Kotlin&amp;#8217;s type inference comes into play here and allows you to call &lt;code&gt;it.method()&lt;/code&gt; inside the conditional statement because it &lt;em&gt;knows&lt;/em&gt; &lt;code&gt;it&lt;/code&gt; cannot be &lt;code&gt;null&lt;/code&gt; inside that context.
The compiler has inferred that the type of &lt;code&gt;it&lt;/code&gt; within that block is &lt;code&gt;Object&lt;/code&gt; and not &lt;code&gt;Object?&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;You can also use the Groovy style &lt;em&gt;Elvis&lt;/em&gt; operator – &lt;code&gt;it?.method()&lt;/code&gt;.
The type of such an expression is the nullable form of &lt;code&gt;method&lt;/code&gt;'s return type so in order to use the result for anything you&amp;#8217;ll have to ensure that it in turn is not &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Type inferences also means that a non-nullable reference can always be assigned to a reference that is a nullable form of the same type.
So given a variable of type &lt;code&gt;String&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="kotlin language-kotlin"&gt;val s = "o hai I'm a String and definitely not null"&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;We can assign it to a &lt;code&gt;String?&lt;/code&gt; variable:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="kotlin language-kotlin"&gt;var maybeString: String?
maybeString = s&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;We can also pass it directly to methods accepting &lt;code&gt;String?&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="kotlin language-kotlin"&gt;fun myMethod(maybeString: String?)

myMethod(s)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;In Java 8 or Scala we&amp;#8217;d have to wrap the value with &lt;code&gt;Optional.of(s)&lt;/code&gt; or &lt;code&gt;Some(s)&lt;/code&gt; in order to do the equivalent.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;As Peter points out in his post using Java libraries inevitably means handling nullable types.
However Kotlin has another trick up its sleeve with the &lt;a href="https://github.com/JetBrains/kannotator"&gt;Kannotator&lt;/a&gt; tool.
Kannotator infers nullability of parameters and return types in an API by analyzing the byte code, looking for &lt;code&gt;@NotNull&lt;/code&gt; annotations, and so on.
The output of Kannotator is an ugly directory full of XML files but luckily you can completely ignore that – it&amp;#8217;s purely for the benefit of the Kotlin compiler and your IDE.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Kotlin also allows for extension functions meaning you can decorate existing types with new functions very easily &lt;em&gt;and with the full benefit of static compilation&lt;/em&gt;.
Extension functions do away with the need for ugly &lt;code&gt;*Utils&lt;/code&gt; type classes and allow for Groovy-like extensions of the Java standard library.
Interestingly you can even create extension functions for nullable types and null itself.
This capability would help solve Peter&amp;#8217;s complaint about having to do a two part null / emtpy check on &lt;code&gt;String?&lt;/code&gt;.
How about:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="kotlin language-kotlin"&gt;fun String?.isEmpty() : boolean = this?.isEmpty()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Java 8 style methods references were &lt;a href="http://blog.jetbrains.com/kotlin/2015/04/upcoming-change-function-types-reform/"&gt;a recent addition to Kotlin&lt;/a&gt; that I haven&amp;#8217;t had much chance to play with yet.
I&amp;#8217;m not sure exactly what problems Peter had with them.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;I&amp;#8217;ve been really impressed with Kotlin.
It feels like a mix of the pragmatism of Groovy with the static compilation and type safety of Scala (in fact I like Kotlin&amp;#8217;s approach to the &lt;code&gt;null&lt;/code&gt; / option problem much more than Scala&amp;#8217;s).
Scala&amp;#8217;s pattern matching is – for me – the stand out feature that Kotlin doesn&amp;#8217;t (yet?) compete with.&lt;/p&gt;
&lt;/div&gt;</content>
  </entry>
  <entry>
    <title>Testing the RxJava poller</title>
    <link rel="alternate" href="http://blog.freeside.co/2015/01/30/testing-the-rxjava-poller/"/>
    <id>http://blog.freeside.co/2015/01/30/testing-the-rxjava-poller/</id>
    <published>2015-01-30T02:15:00-08:00</published>
    <updated>2015-01-30T04:59:42-08:00</updated>
    <author>
      <name>Rob Fletcher</name>
    </author>
    <content type="html">&lt;div class="paragraph"&gt;
&lt;p&gt;Yesterday I posted about &lt;a href="http://blog.freeside.co/2015/01/29/simple-background-polling-with-rxjava/"&gt;an implementation of a simple remote service polling mechanism&lt;/a&gt; using &lt;a href="https://github.com/ReactiveX/RxJava"&gt;RxJava&lt;/a&gt;. One of the things I particularly liked when applying this pattern at work was how straightforward it was to unit test.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Often when dealing with asynchronous processing unit testing can be pretty painful. Typically you need to use a mechanism such as Java&amp;#8217;s &lt;code&gt;CountDownLatch&lt;/code&gt; or Spock&amp;#8217;s &lt;code&gt;BlockingVariables&lt;/code&gt; or &lt;code&gt;PollingConditions&lt;/code&gt; to synchronize threads before making assertions. Allowing processing to run asynchronously, especially when testing scheduled activity can make tests very slow as well.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Ideally tests the asynchronous nature of the code is abstracted and the timer can be faked out. This is exactly the approach that RxJava takes.&lt;/p&gt;
&lt;/div&gt;

&lt;div class="paragraph"&gt;
&lt;p&gt;Recall that we used &lt;code&gt;Schedulers.io()&lt;/code&gt; to ensure that blocking I/O was handled appropriately. If we make that scheduler a property of the &lt;em&gt;poller&lt;/em&gt; object we can replace it in tests with &lt;code&gt;Schedulers.test()&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;If we wrap the polling logic discussed in the previous post up in a &lt;code&gt;start&lt;/code&gt; method of a &lt;code&gt;MessagePoller&lt;/code&gt; class we can have a constructor that looks like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="java language-java"&gt;public MessagePoller(MessageService messageService,
                     Action1&amp;lt;Message&amp;gt; subscriber,
                     Scheduler scheduler) {&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;For the sake of brevity I&amp;#8217;m actually omitting a couple of parameters here – we&amp;#8217;d also want the polling interval and the message recipient to be parameters. For the examples in this post I&amp;#8217;ll hardcode those.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The test scheduler provides a method &lt;code&gt;advanceTimeBy(long, TimeUnit)&lt;/code&gt; that fakes a delay without any time actually having to elapse. For our purposes this is ideal as we can use &lt;code&gt;advanceTimeBy(30, SECONDS)&lt;/code&gt; to trigger a poll on the remote service.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It&amp;#8217;s very easy to write a test that ensures the subscriber is sent a message returned by the remote service.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;def messageService = Stub(MessageService)
def subscriber = Mock(Action1)
@Shared scheduler = Schedulers.test()

@Subject messagePoller = new MessagePoller(messageService,
                                           subscriber,
                                           scheduler)

def "subscriber can receive a single message"() {
  given: "the remote service will return a single message"
  messageService.recentMessages(_) &amp;gt;&amp;gt; [message]

  and: "polling has started"
  messagePoller.start()

  when: "the next poll is triggered"
  scheduler.advanceTimeBy(30, SECONDS)

  then: "the subscriber receives the message"
  1 * subscriber.call(message)

  where:
  message = new Message("1", "Hi", "Cam", "Rob")
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;We stub the response from the remote service, start polling, fake the interval ocurring and then assert that our subscriber mock receives the message. There&amp;#8217;s no thread synchronization and the test runs almost instantaneously.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;We can just as easily test that messages are streamed consistently from multiple calls to the remote service.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;def "subscriber can receive multiple messages from multiple polls"() {
  given:
  messageService.recentMessages(_) &amp;gt;&amp;gt;
      [message1, message2] &amp;gt;&amp;gt;
      [message3]

  and:
  messagePoller.start()

  when:
  scheduler.advanceTimeBy(60, SECONDS)

  then:
  with(subscriber) {
    1 * call(message1)
    1 * call(message2)
    1 * call(message3)
  }

  where:
  message1 = new Message("1", "Hi", "Cam", "Rob")
  message2 = new Message("2", "Bye", "Cam", "Rob")
  message3 = new Message("3", "Hi", "Clay", "Rob")
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here we trigger two polls by advancing the time further and ensuring that the subscriber recieves all the messages.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The test sets up two sequential return values for the &lt;code&gt;messageService&lt;/code&gt; stub using Spock&amp;#8217;s chaining syntax. The first time &lt;code&gt;messageServices.recentMessages&lt;/code&gt; gets called it will respond with &lt;code&gt;[message1, message2]&lt;/code&gt; and the second time it will respond with &lt;code&gt;[message3]&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Using the same technique we can also test that exceptions do not stop the polling mechanism.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;def "polling continues after an error from the message service"() {
  given:
  messageService.recentMessages(_) &amp;gt;&amp;gt;
      [message1] &amp;gt;&amp;gt;
      { throw MockHttpException.newInternalError(null) } &amp;gt;&amp;gt;
      [message2]

  and:
  messagePoller.start()

  when:
  scheduler.advanceTimeBy(90, SECONDS)

  then:
  2 * subscriber.call(_)

  where:
  message1 = new Message("1", "Hi", "Tomas", "Rob")
  message2 = new Message("2", "Bye", "Tomas", "Rob")
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here we poll the remote service three times. Using Spock&amp;#8217;s stub chaining we&amp;#8217;ve set up 3 responses, the second of which will throw an exception. We then assert that both messages arrive because the exception was not allowed to kill the stream.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It&amp;#8217;s similarly straightforward to test other aspects of the polling mechanism; message filtering by recipient, de-duplication and so on.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;For those that are interested in playing with this I have published a small &lt;a href="https://github.com/robfletcher/rx-message-poll"&gt;GitHub project&lt;/a&gt; containing this example and its tests.&lt;/p&gt;
&lt;/div&gt;</content>
  </entry>
  <entry>
    <title>Simple background polling with RxJava</title>
    <link rel="alternate" href="http://blog.freeside.co/2015/01/29/simple-background-polling-with-rxjava/"/>
    <id>http://blog.freeside.co/2015/01/29/simple-background-polling-with-rxjava/</id>
    <published>2015-01-29T03:34:00-08:00</published>
    <updated>2015-01-29T07:48:41-08:00</updated>
    <author>
      <name>Rob Fletcher</name>
    </author>
    <content type="html">&lt;div class="paragraph"&gt;
&lt;p&gt;I&amp;#8217;ve done odd bits of playing around with RxJava before but never dived into it very deeply. Today I wanted to re-implement an unreliable background polling operation and &lt;a href="https://twitter.com/tomaslin"&gt;Tomás Lin&lt;/a&gt; suggested I look at using &lt;a href="https://github.com/ReactiveX/RxJava"&gt;RxJava&lt;/a&gt;. This may be an obvious implementation to some but I had to do a bit of experimentation (and searching Stack Overflow) to come up with it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Imagine we&amp;#8217;re polling a web-service regularly. The service returns a JSON array of independent items (think events since last poll, Tweets with a particular hashtag or something similar). We want to do some processing (filtering, parsing to a type) on each item and then pass them off to a handler.&lt;/p&gt;
&lt;/div&gt;

&lt;div class="paragraph"&gt;
&lt;p&gt;The first thing we need is a heartbeat so:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="java language-java"&gt;Observable.interval(30, TimeUnit.SECONDS)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;That will return an &lt;code&gt;Observable&amp;lt;Long&amp;gt;&lt;/code&gt; that emits a value every 30 seconds. The values are clock ticks starting at zero.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;At each tick we want to poll a remote service. For the sake of simplicity let&amp;#8217;s assume we&amp;#8217;re using a REST client like &lt;a href="http://square.github.io/retrofit/"&gt;Retrofit&lt;/a&gt; that does the HTTP transport and JSON parsing for us so we have an interface like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="java language-java"&gt;public interface MessageService {
  // annotations are ommitted but this method makes a REST call
  List&amp;lt;Message&amp;gt; getRecentMessages();
}

public interface Message {
  boolean isFor(Recipient recipient);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;How do we translate our tick sequence into calls to &lt;code&gt;getRecentMessages&lt;/code&gt;? We can think of it as a &lt;em&gt;map&lt;/em&gt; operation – just one in which we don&amp;#8217;t care about the original value.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="java language-java"&gt;Observable.interval(30, TimeUnit.SECONDS)
          .map((tick) -&amp;gt; messageService.getRecentMessages())&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Now we have an &lt;code&gt;Observable&amp;lt;List&amp;lt;Message&amp;gt;&amp;gt;&lt;/code&gt;. So far so good. However, that &lt;code&gt;map&lt;/code&gt; operation is doing blocking I/O so we should shift it onto an appropriate scheduler (yes, Retrofit can return &lt;code&gt;rx.Observable&lt;/code&gt; so we could handle this in a non-blocking way but I&amp;#8217;ll skip that for the purposes of this discussion).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="java language-java"&gt;Observable.interval(30, TimeUnit.SECONDS, Schedulers.io())
          .map(tick -&amp;gt; messageService.getRecentMessages())&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;For this example we&amp;#8217;ll consume the messages by just subscribing and logging what we get.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="java language-java"&gt;Observable.interval(30, TimeUnit.SECONDS, Schedulers.io())
          .map(tick -&amp;gt; messageService.getRecentMessages())
          .subscribe(messages -&amp;gt; {
            // the subscriber is called with List&amp;lt;Message&amp;gt; every time
            // the remote service is polled
            for (Message message : messages) {
              log.info(message.toString())
            }
          })&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Of course the call to the remote service may fail – the service may be down or rate limiting us for example. We need to ensure our subscription doesn&amp;#8217;t end because the call threw an exception. We could add a &lt;code&gt;try/catch&lt;/code&gt; around the remote call but RxJava has a mechanism for retrying that is a little neater.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="java language-java"&gt;Observable.interval(30, TimeUnit.SECONDS, Schedulers.io())
          .map(tick -&amp;gt; messageService.getRecentMessages())
          .retry()
          .subscribe(messages -&amp;gt; {
            for (Message message : messages) {
              log.info(message.toString())
            }
          })&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Now any exceptions are swallowed and the poll will get repeated at the next interval. We could get more sophisticated here and use a back-off policy but the key point is the subscriber only has to deal with messages that were successfully retrieved.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;That said, we probably want to know the remote service is giving us trouble so let&amp;#8217;s add some logging.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="java language-java"&gt;Observable.interval(30, TimeUnit.SECONDS, Schedulers.io())
          .map(tick -&amp;gt; messageService.getRecentMessages())
          // The error handler is called with any exception raised upstream
          .doOnError(err -&amp;gt; log.error("Error retrieving messages", err))
          // Errors do not propagate past retry so they must be handled before
          .retry()
          .subscribe(messages -&amp;gt; {
            for (Message message : messages) {
              log.info(message.toString())
            }
          })&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Now the next thing we need to do is filter out any messages not intended for us. That&amp;#8217;s pretty easy with another &lt;code&gt;map&lt;/code&gt; operation on the &lt;code&gt;List&amp;lt;Message&amp;gt;&lt;/code&gt; emitted every time we poll.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="java language-java"&gt;Observable.interval(30, TimeUnit.SECONDS, Schedulers.io())
          .map(tick -&amp;gt; messageService.getRecentMessages())
          .doOnError(err -&amp;gt; log.error("Error retrieving messages", err))
          .retry()
          .map(messages -&amp;gt;
            // a 2nd map operation is called with the List&amp;lt;Message&amp;gt; emitted upstream
            messages.stream()
                    // filter to a sub-list containing only "our" messages
                    .filter(message -&amp;gt; message.isFor(recipient))
                    // turn sub-list stream back into a List&amp;lt;Message&amp;gt;
                    .collect(Collectors.toList()))
          .subscribe(messages -&amp;gt; {
            for (Message message : messages) {
              log.info(message.toString())
            }
          })&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;At this point everything is working but notice that we&amp;#8217;re always dealing with &lt;code&gt;List&amp;lt;Message&amp;gt;&lt;/code&gt;. The grouping is just an artifact of the way the messages are retrieved from the remote service. We really should be dealing with a stream of individual messages. I scratched my head on this one for a little while until &lt;a href="https://twitter.com/jon_k_schneider/status/560582822767759360"&gt;Jon Schneider&lt;/a&gt; and &lt;a href="https://twitter.com/tim_yates/status/560582608015597568"&gt;Tim Yates&lt;/a&gt; provided me with an obvious and simple solution.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="java language-java"&gt;Observable.interval(30, TimeUnit.SECONDS, Schedulers.io())
          .map(tick -&amp;gt; messageService.getRecentMessages())
          .doOnError(err -&amp;gt; log.error("Error retrieving messages", err))
          .retry()
          // turns each List&amp;lt;Message&amp;gt; into an Observable&amp;lt;Message&amp;gt; that flatMap
          // will join into a single stream
          .flatMap(Observable::from)
          .filter(message -&amp;gt; message.isFor(recipient))
          .subscribe(message -&amp;gt; log.info(message.toString()))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The &lt;code&gt;flatMap&lt;/code&gt; method allows you to produce a new &lt;code&gt;Observable&lt;/code&gt; for each value emitted from upstream and coalesceses them into a single downstream &lt;code&gt;Observable&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This is much neater. Now the downstream operations are free to deal with individual messages – we can handle the recipient filtering with a simple &lt;code&gt;filter&lt;/code&gt; operation instead of mapping the original list to a sub-list and we no longer need to loop over multiple messages in the subscriber.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;One last thing is that perhaps our remote service will give us some duplicate messages on subsequent calls. An ideal way to handle that would be to send a last message id or an HTTP &lt;code&gt;If-Modified-Since&lt;/code&gt; header with the request but if that&amp;#8217;s not an option Rx can help us.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="java language-java"&gt;Observable.interval(30, TimeUnit.SECONDS, Schedulers.io())
          .map(tick -&amp;gt; messageService.getRecentMessages())
          .doOnError(err -&amp;gt; log.error("Error retrieving messages", err))
          .retry()
          .flatMap(Observable::from)
          // filter out any previously seen messages
          .distinct()
          .filter(message -&amp;gt; message.isFor(recipient))
          .subscribe(message -&amp;gt; log.info(message.toString()))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Obviously using &lt;code&gt;distinct&lt;/code&gt; assumes that our &lt;code&gt;Message&lt;/code&gt; objects are unique and implement &lt;code&gt;hashCode&lt;/code&gt; properly.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;We now have a filtered stream of unique messages generated by polling a remote service in an error-tolerant way.&lt;/p&gt;
&lt;/div&gt;</content>
  </entry>
  <entry>
    <title>Fixing current time for tests with Java 8's date/time API</title>
    <link rel="alternate" href="http://blog.freeside.co/2015/01/15/fixing-current-time-for-tests-with-java-8-s-date-time-api/"/>
    <id>http://blog.freeside.co/2015/01/15/fixing-current-time-for-tests-with-java-8-s-date-time-api/</id>
    <published>2015-01-15T06:19:00-08:00</published>
    <updated>2015-01-15T06:33:35-08:00</updated>
    <author>
      <name>Rob Fletcher</name>
    </author>
    <content type="html">&lt;div class="paragraph"&gt;
&lt;p&gt;For years I&amp;#8217;ve used the Joda Time library to provide a nicer alternative to the horrible mutable &lt;code&gt;java.util.Date&lt;/code&gt; class and the terrifying abyss of &lt;code&gt;java.util.Calendar&lt;/code&gt;. One thing, as a fanatical tester, that really appealed to me was the existence of the &lt;code&gt;DateTimeUtils&lt;/code&gt; class. All the Joda Time types use &lt;code&gt;DateTimeUtils&lt;/code&gt; as a source of the current instant and it exposes methods that allow tests to fix or offset the value that&amp;#8217;s returned. That can rule out some irritating flakiness in tests and enable testing of time zone / daylight savings bugs, timeout logic and so on while retaining the encapsulation of timestamp generation in production code.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Of course, when you look at &lt;code&gt;DateTimeUtils&lt;/code&gt; with purist eyes it&amp;#8217;s a horrible hack. A static singleton encapsulating global mutable state! I guess that was the attitude of those responsible for JSR-352 that created the new &lt;code&gt;java.time&lt;/code&gt; package which is largely based on Joda Time. One of the things that &lt;em&gt;wasn&amp;#8217;t&lt;/em&gt; carried over from Joda Time is the &lt;code&gt;DateTimeUtils&lt;/code&gt; class. Instead factory methods such as &lt;code&gt;Instant.now()&lt;/code&gt; use a &lt;code&gt;Clock&lt;/code&gt; object – by default &lt;code&gt;Clock.systemUTC()&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;

&lt;div class="paragraph"&gt;
&lt;p&gt;The docs for &lt;code&gt;java.time.Clock&lt;/code&gt; state:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="quoteblock"&gt;
&lt;blockquote&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The primary purpose of this abstraction is to allow alternate clocks to be plugged in as and when required. Applications use an object to obtain the current time rather than a static method. This can simplify testing.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Best practice for applications is to pass a &lt;code&gt;Clock&lt;/code&gt; into any method that requires the current instant.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Honestly &lt;em&gt;the only time&lt;/em&gt; I can think I&amp;#8217;d want to use an alternate &lt;code&gt;Clock&lt;/code&gt; implementation is when testing and now instead of a simple hack like:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;given: DateTimeUtils.setCurrentMillisFixed(Random.nextLong())
when: // I do something
then: // something happens
cleanup: DateTimeUtils.setCurrentMillisSystem()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;I have to pass a fixed &lt;code&gt;Clock&lt;/code&gt; into the class/system under test. This is all very well in a dependency injection context but it&amp;#8217;s no fun when the timestamps are in value objects that have no reason to expose variant clock behavior to other elements of the production system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;I hate having to drill holes into my production code to enable tests to do things like this. If the graph of objects under test is a couple of layers deep you may need to add &lt;code&gt;Clock&lt;/code&gt; parameters in several places to generate timestamps in a controlled way where you need to. If you need to use multiple different fixed clocks to test a certain condition (ordering model objects based on their last update time, for example) then you need to expose a &lt;em&gt;setter&lt;/em&gt; for the &lt;code&gt;Clock&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;So in order to avoid the evil singleton anti-pattern instead we need to break object encapsulation and expose mutable state on objects just for the benefit of tests. I&amp;#8217;m sure I&amp;#8217;m not the only one to whom this doesn&amp;#8217;t feel like an improvement.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;So what happens? I reinvent &lt;code&gt;DateTimeUtils&lt;/code&gt; by creating a static singleton with a global &lt;code&gt;Clock&lt;/code&gt; property that I can set at will directly from the test. Each place in the code that needs to generate a timestamp needs to remember to use the singleton in order that timestamps are consistently generated.&lt;/p&gt;
&lt;/div&gt;</content>
  </entry>
  <entry>
    <title>How can test it if I don't know what I'm building yet?</title>
    <link rel="alternate" href="http://blog.freeside.co/2014/09/24/how-can-i-test-it-if-i-dont-know-what-im-building-yet/"/>
    <id>http://blog.freeside.co/2014/09/24/how-can-i-test-it-if-i-dont-know-what-im-building-yet/</id>
    <published>2014-09-24T02:26:00-07:00</published>
    <updated>2014-09-24T06:46:44-07:00</updated>
    <author>
      <name>Rob Fletcher</name>
    </author>
    <content type="html">&lt;div class="paragraph"&gt;
&lt;p&gt;One objection to the practice of TDD I&amp;#8217;ve heard from several different people is along the lines of &lt;em&gt;“I don&amp;#8217;t know exactly what I&amp;#8217;m building at the outset, the code is experimental, so how can I write tests for it?”&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Frequently it is the case that you have an idea but don&amp;#8217;t know the mechanics of how you&amp;#8217;re going to implement it. I find this particularly when I&amp;#8217;m writing code that extends a third-party library. You don&amp;#8217;t know exactly where the API hooks you&amp;#8217;ll need to use are, your understanding of the API is fuzzy and you expect to learn it as you go. So how do you test-drive in that situation?&lt;/p&gt;
&lt;/div&gt;

&lt;div class="paragraph"&gt;
&lt;p&gt;XP has a recommendation here: write a &lt;a href="http://www.extremeprogramming.org/rules/spike.html"&gt;&lt;em&gt;spike&lt;/em&gt;&lt;/a&gt; then throw the code away once you have enough understanding of the technical solution to approach the problem in a more rigorous manner. In my experience that practice, while valid, doesn&amp;#8217;t sell TDD to a doubter.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;What I think really causes the original objection is that the person in question is thinking at the wrong level. They&amp;#8217;re mentally diving straight in to code, to the solution, to the elegant and shining temple of technical brilliance they&amp;#8217;re about to erect. They&amp;#8217;re thinking about &lt;em&gt;how&lt;/em&gt; not &lt;em&gt;what&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Step back. Sure, you don&amp;#8217;t know what your code is going to look like or how it&amp;#8217;s going to interface with anything. If you try to start with low-level unit tests now you &lt;em&gt;will&lt;/em&gt; spend a lot of time re-writing tests for fine-grained interactions when you need to take a different approach.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Two things you &lt;em&gt;do&lt;/em&gt; know are what is going in to this thing you&amp;#8217;re going to build and what you want to come out of the other side.&lt;span class="footnote"&gt;[&lt;a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote."&gt;1&lt;/a&gt;]&lt;/span&gt; So test that. Test that at a high level.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Writing a static asset pipeline that concatenates and minifies JavaScript and CSS files? Write a test that uses example files and makes assertions about what the result should look like. Writing an authentication system for a web-app? Write some browser-based tests that register accounts, log in, log out and verify authentication state via the user interface that doesn&amp;#8217;t exist yet. If you&amp;#8217;re using Cucumber you don&amp;#8217;t need to implement all the detail of the steps yet. If you&amp;#8217;re using Spock or JUnit (or RSpec, Scalaz, Jasmine or whatever) then compose an abstraction for the tests and leave out undefined details you don&amp;#8217;t know. Use sensible assumptions you can easily change (we&amp;#8217;re probably going to ask for a username and password), no-op helper methods (we don&amp;#8217;t know exactly how we&amp;#8217;ll verify the user is logged in just yet so we&amp;#8217;ll write a helper &lt;code&gt;isLoggedInAs(username)&lt;/code&gt;), elide over the irrelevant detail (we might require some other information when a user registers but we can add that later).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;None of those things require you to know how the code you&amp;#8217;re going to write is going to work. They require you to think about and formally specify what you expect in the way of input and output. It forces you to define the coarse-grained behavior of the software you&amp;#8217;re designing – &lt;em&gt;what&lt;/em&gt; you want it to do. The &lt;em&gt;how&lt;/em&gt; now has a framework for success into which it can grow.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;In &lt;a href="http://www.growing-object-oriented-software.com"&gt;&lt;em&gt;Growing Object-Oriented Software Guided By Tests&lt;/em&gt;&lt;/a&gt; Steve Freeman and Nat Pryce describe this style of testing as &lt;em&gt;outside-in&lt;/em&gt;. You start with high level tests using a &lt;em&gt;“walking skeleton”&lt;/em&gt; and progressively work inward adding more detail and drilling down to low-level unit tests and the accompanying fine-grained behavior. The &lt;em&gt;walking skeleton&lt;/em&gt; is fleshed out as you go and by the end of the process has evolved into a passing end-to-end acceptance test suite.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="footnotes"&gt;
&lt;hr&gt;
&lt;div class="footnote" id="_footnote_1"&gt;
&lt;a href="#_footnoteref_1"&gt;1&lt;/a&gt; If you don&amp;#8217;t know &lt;em&gt;that&lt;/em&gt; I&amp;#8217;m pretty sure you need to figure it out before you start writing any code.
&lt;/div&gt;
&lt;/div&gt;</content>
  </entry>
  <entry>
    <title>Multiple interface mocks with Spock</title>
    <link rel="alternate" href="http://blog.freeside.co/2014/08/11/multiple-interface-mocks-with-spock/"/>
    <id>http://blog.freeside.co/2014/08/11/multiple-interface-mocks-with-spock/</id>
    <published>2014-08-11T03:46:00-07:00</published>
    <updated>2014-08-11T09:03:10-07:00</updated>
    <author>
      <name>Rob Fletcher</name>
    </author>
    <content type="html">&lt;div class="paragraph"&gt;
&lt;p&gt;Spock&amp;#8217;s &lt;code&gt;Mock&lt;/code&gt; factory method (as well as factories for the other types of test double; &lt;code&gt;Stub&lt;/code&gt; &amp;amp; &lt;code&gt;Spy&lt;/code&gt;) accepts a single interface representing the type you need a test double for. But what should you do if you need a test double that implements multiple interfaces?&lt;/p&gt;
&lt;/div&gt;

&lt;div class="paragraph"&gt;
&lt;p&gt;In some situations where code accepts flexible parameter types and is using runtime dispatching (or &lt;code&gt;instanceof&lt;/code&gt; checks) internally to perform different behavior we&amp;#8217;d want to test that different types were handled correctly.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;A trivial example might be a method like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;class A {
  private Writer writer

  void handle(Writable thing) {
    try {
      thing.writeTo(writer)
    } finally {
      if (thing instanceof Closeable) {
        thing.close()
      }
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;we&amp;#8217;d want to test that not only is the &lt;code&gt;writeTo&lt;/code&gt; method from &lt;code&gt;Writable&lt;/code&gt; called but that if the parameter we pass is &lt;code&gt;Closeable&lt;/code&gt; it gets closed properly as well.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The simplest case, where the parameter &lt;em&gt;isn&amp;#8217;t&lt;/em&gt; &lt;code&gt;Closeable&lt;/code&gt; is easy to test:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;@Subject a = new A()

def "writes a writable"() {
  given:
  def x = Mock(Writable)

  when:
  a.handle(x)

  then:
  1 * x.writeTo(_)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;But when we need the mock parameter to implement the &lt;code&gt;Closeable&lt;/code&gt; interface as well as &lt;code&gt;Writable&lt;/code&gt; in order to drive the variant behavior it&amp;#8217;s not so obvious what to do. The following tests will fail because the &lt;code&gt;isntanceof&lt;/code&gt; check in the &lt;code&gt;handle&lt;/code&gt; method will return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;def "writes and closes a closeable writable"() {
  given:
  def x = Mock(Writable)

  when:
  a.handle(x)

  then:
  1 * x.writeTo(_)

  then:
  1 * x.close()
}

def "closes a closeable even if writing fails"() {
  given:
  def x = Mock(Writable) {
    writeTo(_) &amp;gt;&amp;gt; { throw new IOException() }
  }

  when:
  a.handle(x)

  then:
  thrown IOException

  and:
  1 * x.close()
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Although it might be nice you cannot do something like:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;def mock = Mock(Comparable, Closeable)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;We could cast around for some class that happens to implement both interfaces and then use a &lt;code&gt;Spy&lt;/code&gt; but the simplest and cleanest solution is to just create our own interface inside the specification class:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;private static interface CloseableWritable extends Writable, Closeable {}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Then in the feature methods we can just use:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code class="groovy language-groovy"&gt;given:
def x = Mock(CloseableWritable)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;In retrospect this solution is the most obvious thing in the world but it took me a little while to remember that an interface can extend more than one other interface. Since we never actually need to implement &lt;code&gt;CloseableWritable&lt;/code&gt; with anything other than a mock it makes sense to encapsulate it inside the specification class.&lt;/p&gt;
&lt;/div&gt;</content>
  </entry>
</feed>
